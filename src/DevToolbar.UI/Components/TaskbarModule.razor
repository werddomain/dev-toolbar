@using DevToolbar.Core.Interfaces
@using DevToolbar.Core.Models
@implements IDisposable
@inject IWindowService WindowService
@inject IGlobalSettingsService GlobalSettingsService

@if (_isVisible && _windows.Count > 0)
{
    <div class="taskbar-module">
        <div class="taskbar-divider"></div>
        <div class="taskbar-windows">
            @foreach (var win in _windows)
            {
                <button class="taskbar-window-btn @(win.IsActive ? "active" : "")"
                        @onclick="() => OnWindowClicked(win)"
                        title="@win.Title">
                    @if (!string.IsNullOrEmpty(win.IconBase64))
                    {
                        <img src="data:image/png;base64,@win.IconBase64"
                             alt="@win.ProcessName"
                             class="taskbar-window-icon" />
                    }
                    else
                    {
                        <span class="taskbar-window-icon-placeholder">ðŸªŸ</span>
                    }
                    <span class="taskbar-window-title">@TruncateTitle(win.Title)</span>
                </button>
            }
        </div>
    </div>
}

@code {
    private List<WindowInfo> _windows = new();
    private bool _isVisible;
    private CancellationTokenSource? _pollCts;
    private int _monitorIndex;
    private int _pollingIntervalMs = 1500;

    protected override void OnInitialized()
    {
        var settings = GlobalSettingsService.Current;
        _isVisible = settings.ShowActiveWindows;
        _monitorIndex = settings.TargetMonitorIndex;
        _pollingIntervalMs = settings.WindowPollingIntervalMs;

        GlobalSettingsService.OnSettingsChanged += OnSettingsChanged;

        if (_isVisible)
        {
            StartPolling();
        }
    }

    private void OnSettingsChanged(GlobalSettings settings)
    {
        var wasVisible = _isVisible;
        _isVisible = settings.ShowActiveWindows;
        _monitorIndex = settings.TargetMonitorIndex;
        _pollingIntervalMs = settings.WindowPollingIntervalMs;

        if (_isVisible && !wasVisible)
        {
            StartPolling();
        }
        else if (!_isVisible && wasVisible)
        {
            StopPolling();
            _windows.Clear();
        }

        _ = InvokeAsync(StateHasChanged);
    }

    private void StartPolling()
    {
        StopPolling();
        _pollCts = new CancellationTokenSource();
        _ = PollWindowsAsync(_pollCts.Token);
    }

    private void StopPolling()
    {
        _pollCts?.Cancel();
        _pollCts?.Dispose();
        _pollCts = null;
    }

    private async Task PollWindowsAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            try
            {
                var windows = await WindowService.GetOpenWindowsOnMonitorAsync(_monitorIndex);
                _windows = windows;
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"[TaskbarModule] Poll error: {ex.Message}");
            }

            try
            {
                await Task.Delay(_pollingIntervalMs, ct);
            }
            catch (TaskCanceledException)
            {
                break;
            }
        }
    }

    private void OnWindowClicked(WindowInfo window)
    {
        try
        {
            WindowService.ActivateWindow(window.Hwnd);
        }
        catch
        {
            // Window may have closed â€” silently ignore, next poll will remove it
        }
    }

    private static string TruncateTitle(string title, int maxLength = 24)
    {
        if (string.IsNullOrEmpty(title)) return string.Empty;
        return title.Length <= maxLength ? title : title[..(maxLength - 1)] + "â€¦";
    }

    public void Dispose()
    {
        StopPolling();
        GlobalSettingsService.OnSettingsChanged -= OnSettingsChanged;
    }
}
